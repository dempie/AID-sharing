---
title: "R Notebook"
output: html_notebook
---
In this notebook I will add the fucntion useful for this project that I have created or stolen from someone.

## prepare_munge

This function is useful to format GWAS summary statistic as the munge function from GenomicSEM wants them. 

```{r prepare_munge }
prepare_munge <- function(sum_stats, rsID, the_effect_allele, the_non_effect_allele, pvalue, effect_size, the_SE=NA, the_chr=NA, the_bp=NA, to_remove=NA, path = NA){
  #an error if arguments are not provided 
  if (missing(sum_stats) | missing(rsID) | missing(the_effect_allele) | missing(the_non_effect_allele) |missing(pvalue) | missing(effect_size) ) {
    stop( 'At least one argument is missing')
    
      } else {
        
          require(dplyr)
          require(data.table)
          sum_stats <- sum_stats  %>% rename(c(SNP = rsID, A1 = all_of(the_effect_allele), A2 = all_of(the_non_effect_allele), p = all_of(pvalue), effect = all_of(effect_size)))
          sum_stats$SNP <- tolower(sum_stats$SNP)
          sum_stats$p <- as.numeric(sum_stats$p)
          sum_stats$effect <- as.numeric(sum_stats$effect)
          
          #conditional options 
                #remove columns
                if(!is.na(to_remove[1])){sum_stats <- select(sum_stats,-(all_of(to_remove)))} 
                      
                #rename SE column
                if(!is.na(the_SE)){ 
                      sum_stats <- rename(sum_stats, SE=all_of(the_SE))
                      sum_stats$SE <- as.numeric(sum_stats$SE)
                      }
              
                #rename the CHR column
                if(!is.na(the_chr)){ sum_stats <-  rename(sum_stats, CHR=all_of(the_chr))}
              
                #rename the BP column
                if(!is.na(the_bp)){ sum_stats <- rename(sum_stats, BP=all_of(the_bp))}
          
                #save the file if a path is provided
                if(is.na(path)){
                    invisible(sum_stats)
                  
                  
                } else {
                  
                  fwrite(sum_stats, path, sep = '\t', col.names = T, row.names = F, quote = F)
                  invisible(sum_stats)
                }
              }
}

```


## qc_summary_stats 
takes as output of prepare_munge and outputs the number of SNP with rsID, 
```{r qc summary stats}
qc_summary_stats <- function(sum_stats, plots=F){
          #compute number of SNPs
          n_SNPs <- nrow(sum_stats)
          
          #compute the number of unique rsIDs 
          sum_stats_rsIDs<- sum_stats[grep('rs',sum_stats$SNP),]
          n_rsIDs <- length(unique(sum_stats_rsIDs$SNP))
          
          SNP_per_chr <- vector(mode='integer', length = 22)
          rsID_per_chr <-  vector(mode='integer', length = 22)
          
          #compute the number of unique rsIDs and SNPs per chromosome 
          for(i in c(1:22)){
            
                SNP_per_chr[i] <- nrow(sum_stats[sum_stats$CHR== i ,]) 
                rsID_per_chr[i] <- length(unique(sum_stats_rsIDs[sum_stats_rsIDs$CHR == i, ]$SNP))
          }
          
          qc_metrics_SNPs <- cbind(Chromosome = c(1:22) ,n_SNPs = SNP_per_chr )
          qc_metrics_rsIDs <- cbind(Chromosome = c(1:22) ,n_rsIDs = rsID_per_chr )
          
          cat(paste0( 'Total number of SNP  ' , n_SNPs , '\n', 
                      'Total number of SNP with rsID  ', n_rsIDs, '\n')
          )
          
          output <- list(qc_SNPs = qc_metrics_SNPs, qc_rsIDs=qc_metrics_rsIDs )
          
          
          
          if(plots==T){

            barplot(t(output$qc_SNPs) , main = 'Number of unique rsID per chromosome',  ylab = 'Number of SNP', 
                    names.arg = k$qc_SNPs[,1], cex.names = 0.8, 
                    legend.text =  paste0( 'Total number of SNP with rsID  ', n_rsIDs))
          }
          
          return(output)   
          
}
```


## semPlotModel_GSEM

This function transforms the output from genomic sem in an object that can be used by the semPlot function to draw paths for factor analysis representation. 
```{r semPlotModel_GSEM}
semPlotModel_GSEM=function(gsem.object=GWISoutput , est.label="STD_All"){ 
  require(semPlot)
  object=gsem.object$results
  object$free=0
  numb=1:length(which(object$op!="~~"))
  object$free[which(object$op!="~~")]=numb
  varNames <- lavaanNames(object, type = "ov")
  factNames <- lavaanNames(object, type = "lv")
  factNames <- factNames[!factNames %in% varNames]
  n <- length(varNames)
  k <- length(factNames)
  if (is.null(object$label)) 
    object$label <- rep("", nrow(object))
  semModel <- new("semPlotModel")
  object$est <- object[,est.label]
  if (is.null(object$group)) 
    object$group <- ""
  semModel@Pars <- data.frame(label = object$label, lhs = ifelse(object$op == 
                                                                   "~" | object$op == "~1", object$rhs, object$lhs), edge = "--", 
                              rhs = ifelse(object$op == "~" | object$op == "~1", object$lhs, 
                                           object$rhs), est = object$est, std = NA, group = object$group, 
                              fixed = object$free==0, par = object$free, stringsAsFactors = FALSE)
  semModel@Pars$edge[object$op == "~~"] <- "<->"
  semModel@Pars$edge[object$op == "~*~"] <- "<->"
  semModel@Pars$edge[object$op == "~"] <- "~>"
  semModel@Pars$edge[object$op == "=~"] <- "->"
  semModel@Pars$edge[object$op == "~1"] <- "int"
  semModel@Pars$edge[grepl("\\|", object$op)] <- "|"
  semModel@Thresholds <- semModel@Pars[grepl("\\|", semModel@Pars$edge), 
                                       -(3:4)]
  semModel@Pars <- semModel@Pars[!object$op %in% c(":=", "<", 
                                                   ">", "==", "|", "<", ">"), ]
  semModel@Vars <- data.frame(name = c(varNames, factNames), 
                              manifest = c(varNames, factNames) %in% varNames, exogenous = NA, 
                              stringsAsFactors = FALSE)
  semModel@ObsCovs <- list()
  semModel@ImpCovs <- list()
  semModel@Computed <- FALSE
  semModel@Original <- list(object)
  return(semModel)
  
}
```


## split_sum_stats
This function is meant to seaprate GWAS summary statas in n chunks of x size, and then recover a specific chunk. This is usefull for running job arrays in the cluster. 

```{r split_sum_stats}
split_sum_stats <- function(summary_stats, chunk_size, which_chunk) {
  require(data.table)
  #give a number to the elements of the sum_states
  my_index <- seq_along(1: nrow(summary_stats))
  n <- nrow(summary_stats) 
  chunks <- rep(1:ceiling(n/chunk_size),each=chunk_size)[1:n] #the last piece [1:n] is necessary because otherwise the last chunk will become long as the chunk size and will replicate it thus exciding the length of the sumstats
  a <- split(my_index, chunks)
  summary_stats[ (a[[which_chunk]]) , ]
}
```


## is_se_logB
This function is for checking if the standard error reported in GWAS summary stats is a standard error of logistic beta. If the calculated and reported are almost identical that it is a selogB.  It plots 10000 randomly selected pvalues andruns a linear model between pcalcualte and reported. I look at the r squared from the linea regression. If >0.99 than we can confidently say the pvalues are identical and thus we are looking at a SE of log(beta)

```{r is_se_logB}
is_se_logB <- function(BETA,SE, PVALUE) {
  p_calculated <- 2*pnorm((abs(BETA) / SE),lower.tail = F)
  p_reported <- PVALUE
  #data.frame(p_calculated, p_reported), 
  a <- lm(p_calculated~p_reported) #fit a linear model to see if they are perfectly correlated 
  print(summary(a))
  
  rand <- sample(1:length(BETA), 10000)
  plot(p_reported[rand], p_calculated[rand]) 
  abline(a, col="red") # regression line (y~x)
  abline(0, 1, col='blue', lty= 4 )
}

```


## calculate_prevalence

A function to calculate the sanple prevalence from a csv which has three columns: consortium, cases, controls. 

https://github.com/GenomicSEM/GenomicSEM/wiki/2.1-Calculating-Sum-of-Effective-Sample-Size-and-Preparing-GWAS-Summary-Statistics
```{r calculate_prevalence}
locus.breaker=function(res,p.sig=5e-8, p.limit=1e-5,hole.size=250000
                       ,p.label="p",chr.label="chr",pos.label="pos"){
  
  res = res[order(as.numeric(res[, chr.label]), as.numeric(res[,pos.label])),]
  
  res=res[which(res[,p.label]<p.limit),]
  trait.res=c()
  for(j in 1:22){
    
    res.chr=res[which(res[,chr.label]==j),]
    if(nrow(res.chr)>1){
      holes=res.chr[,pos.label][-1]-res.chr[,pos.label][-length(res.chr[,pos.label])] 
      gaps=which(holes>hole.size)
      if(length(gaps)>0){
        for(k in 1:(length(gaps)+1)){
          
          if(k==1){
            res.loc=res.chr[1:(gaps[k]),]  
          }else if(k==(length(gaps)+1)){
            res.loc=res.chr[(gaps[k-1]+1):nrow(res.chr),]  
          }else{
            res.loc=res.chr[(gaps[k-1]+1):(gaps[k]),]
          }
          if(min(res.loc[,p.label])<p.sig){
            
            start.pos=min(res.loc[,pos.label],na.rm=T)
            end.pos=max(res.loc[,pos.label],na.rm=T)
            chr=j
            best.snp=res.loc[which.min(res.loc[,p.label]),]
            line.res=c(chr,start.pos,end.pos,unlist(best.snp))
            trait.res=rbind(trait.res,line.res)
          }
          
          
        }
      }else{
        res.loc=res.chr
        if(min(res.loc[,p.label])<p.sig)  {
          
          start.pos=min(res.loc[,pos.label],na.rm=T)
          end.pos=max(res.loc[,pos.label],na.rm=T)
          chr=j
          best.snp=res.loc[which.min(res.loc[,p.label]),]
          line.res=c(chr,start.pos,end.pos,unlist(best.snp))
          trait.res=rbind(trait.res,line.res)
        }
        
      }
      
    }else if(nrow(res.chr)==1){
      
      res.loc=res.chr
      if(min(res.loc[,p.label])<p.sig){
        start.pos=min(res.loc[,pos.label],na.rm=T)
        end.pos=max(res.loc[,pos.label],na.rm=T)
        chr=j
        best.snp=res.loc[which.min(res.loc[,p.label]),]
        line.res=c(chr,start.pos,end.pos,unlist(best.snp))
        trait.res=rbind(trait.res,line.res)
      }
      
      
    }
  }
  
  print(trait.res)
  trait.res=as.data.frame(trait.res,stringsAsFactors=FALSE)
  trait.res=trait.res[,-(which(names(trait.res)==chr.label))]
  names(trait.res)[1:3]=c("chr","start","end")
  trait.res
}
```

## assemble_3f 

This function take a list of chunks and returns a list in which each of the elements is the complete and assemble summary stats for each of the factors. You provide the number of factors estimanted and the fucntion will create as many summary statistics as there are factors.  
The function check the existence of the chunks, returns a warning indicating which chunks are missing and loads then ones that are not missing. That separetes according to the factor and outputs info about the unique number of SNPs per factor and the number of SNPs not estimated. The returning object is a list of summary statistics.
The input= number of expceted chunks is the index of the chunks. 

```{r assemble_3f function}

assemble_f <- function(n_expected_chunks, first_part_of_path, terminal_part_of_path, n_factors ){
  
  
      n_expected_chunks <- c(n_expected_chunks)
        
      #check if files exist and return the one that do not exist
      chunks_found <- lapply(c(n_expected_chunks), function(x)file.exists(paste0(first_part_of_path, x, terminal_part_of_path)))
      missing_chunks <- c(n_expected_chunks)[unlist(chunks_found)==F]
      
        #issue a warning indicating which chunks are missing and that will not be included in the final sumstats
            if((length(missing_chunks))>0) { 
              
              warning(    paste0('SOME CHUNKS ARE MISSING!', '\n',
                          length(n_expected_chunks) - length(missing_chunks), ' chunks were found!', '\n',
                          length(missing_chunks), ' chunks were NOT found!', '\n',
                          'The missing chunks are the ', paste0(missing_chunks, collapse = ' - ') , '\n', 
                          '\n')
                      )
              
            } else {
              
              cat(paste0( length(chunks_found) , ' chunks were found!', '\n', 
                          'There are not missing chunks :) ','\n' ,
                          '\n' ))
            }
      
      
      #load the chunks that have been found
      chunks_to_load <-  c(n_expected_chunks)[unlist(chunks_found)==T]
      
      chunks <- lapply( chunks_to_load , function(x)readRDS(paste0(first_part_of_path, x, terminal_part_of_path )))
      
      cat(paste0('I have loaded ' , length(chunks), ' chunks!', '\n'))
      
      #for each chunk, separate the factors and merge the chunk for each factor
      #allocate the list
      ordered <- list()
      sum_stats <- list()
      
      #cycle through each of the factors (n_factors)
      for(k in c(1:n_factors)) {
        
                #allocate a list in the k element of ordered according to the number of factors
                ordered[[k]] <- list()
                #separate the Factors in the ordered list
                for(i in (1:length(chunks))){
                       ordered[[k]][[i]] <- chunks[[i]][[k]]
                }
                
                #merge the chunks for each facotr, put into a list a name the element of the list
                sum_stats[[k]] <-  do.call(rbind, ordered[[k]]) 
                names(sum_stats)[k] <- paste0('factor', k)
                
                #issue a warning if the number of unique SNP is less then the number of rows
                if( length(unique(sum_stats[[k]]$SNP))!= nrow(sum_stats[[k]]) ){warning('The number of unique SNP is different than the number of rows in F',k ,'!!!' )}
                
                #issue a warning if the cumulative numnber of unique SNPs in the merged dataset is different from the sum of the individual unique SNPs per chunk
                if( nrow(sum_stats[[k]]) != sum(unlist(lapply(ordered[[k]], nrow)))  )  warning('The number of unique SNP is different between the merged and the sum of the individual chunks in F',k,  '!!!')
        
      }
      
      #calculate some useful qc information
        SNPs_unique <- list()
        SNP_error <- list()
      
        qc_info <- for( i in (1:length(sum_stats))){
        
            #number of SNP in total without error
            SNPs_unique[[i]]  <- cat(paste0('The number of unique SNPs in F',i, ' is ', length(unique(sum_stats[[i]]$SNP)), '\n'))
            
            #operator found
            cat('The lhs operators found in F',i, ' are ',  unique(sum_stats[[i]]$lhs), '\n')
            
            #number of SNP not estimated
            SNP_error[[i]] <-  cat(paste0('The number of not estimated SNPs in F', i , ' is ', nrow(sum_stats[[i]][sum_stats[[i]]$error != 0,]), '\n' , 
                                          '\n'))
            
        }
      
      
      invisible(sum_stats)
}

```


## append chunk

This funciton will merge chunks that are coming out the assemble_3 chunks. Important to provde a list of chunks were the elements of the list are list of summary stats for each factor of summary statistics. It issues a warning if something is messed up 
You need to provide the number of facotrs estimated. 
```{r append chunk}
#it takes the output of the aseemble_3f function,
#  
# REMBER TO remove all the accesory outputs from assemble_3f

append_chunk <- function(list_complete, n_factors ){
    
    #allocate list
    ordered <- list()
    sum_stats <- list()
    
    #cycle through each of the factors (n_factors)
    for(k in c(1:n_factors)) {
      
                #allocate a list in the k element of ordered according to the number of factors
                ordered[[k]] <- list()
                #separate the Factors in the ordered list
                for(i in (1:length(list_complete))){
                  ordered[[k]][[i]] <- list_complete[[i]][[k]]
                }
                
                #merge the chunks for each facotr, put into a list a name the element of the list
                sum_stats[[k]] <-  do.call(rbind, ordered[[k]])
                names(sum_stats)[k] <- paste0('factor', k)

                #issue a warning if the number of unique SNP is less then the number of rows
                if( length(unique(sum_stats[[k]]$SNP))!= nrow(sum_stats[[k]]) ){warning('The number of unique SNP is different than the number of rows in F',k ,'!!!' )}

                #issue a warning if the cumulative numnber of unique SNPs in the merged dataset is different from the sum of the individual unique SNPs per chunk
                if( nrow(sum_stats[[k]]) != sum(unlist(lapply(ordered[[k]], nrow)))  )  warning('The number of unique SNP is different between the merged and the sum of the individual chunks in F',k,  '!!!')

              }
    
    #calculate some useful qc information
    SNPs_unique <- list()
    SNP_error <- list()
    
    for( i in (1:length(sum_stats))){
      
                #number of SNP in total without error
                SNPs_unique[[i]]  <- cat(paste0('The number of unique SNPs in F',i, ' is ', length(unique(sum_stats[[i]]$SNP)), '\n'))
                
                #operator found
                cat('The lhs operators found in F',i, ' are ',  unique(sum_stats[[i]]$lhs), '\n')
                
                #number of SNP not estimated
                SNP_error[[i]] <-  cat(paste0('The number of not estimated SNPs in F',i, ' is ', nrow(sum_stats[[i]][sum_stats[[i]]$error != 0,]), '\n' , 
                                              '\n'))
      
    }
    
    
    invisible(sum_stats)
    
}

```

## test_overlap

This function test the overlapp between two datasets. You need to provide the two datasest and the number of chromosomes where you want to perform the overalpp test. It expects the columns to be named CHR, start, end. It outputs a vector of overlapping loci. 
By selection auto_overlapp==T you provide just one dataset and the function will search for the overlapp inside the dataset. The function will return a list of SNP with their respective overlap. 
the iteration counter will be an indicator of the chromosome. 



```{r test_overlap}
test_overlap <-function(input_a, input_b=NA, n_chr=NA, auto_overlapp=F){     
            require(data.table)
            require(stringr)
  
            if(auto_overlapp==T){ 
             
              #allocate the lists
              output <- list()
              colnames(input_a) <- tolower(colnames(input_a))
              overlapping_rsIDs <- list()
              
              #loop through each chromosome 
              for(i in c(unique(as.numeric(input_a$chr)))){
                      #make sure everyhting is numeric
                      a <-as.data.table(input_a)
                      b <- as.data.table(input_a)
                      
                      a$chr <- as.numeric(a$chr)
                      a$start <- as.numeric(a$start)
                      a$end <- as.numeric(a$end)
                      
                      #allocate the lists
                      overlapping_rsIDs[[i]] <-  list()
                      overlapping_rsIDs[[i]][[1]] <- data.frame('iteration'=NA,'Overlapp_with_query'=NA,'Query_SNP'=NA)
                      output[[i]] <- list()
                      
                      #loop for checking the overlapp between each element and the rest of the list
                      for(k in c(1:nrow(a[a$chr==i, ]))){
                  
                  
                              setkey(a,start, end)
                              output[[i]][[k]] <- foverlaps(a[a$chr==i, ][k,], a[a$chr==i,][-k,], type = 'any', which = TRUE, nomatch =NULL)
                              
                              #put the results in a list
                              overlapping_rsIDs[[i]][[1]][k, 1] <-  paste0(i,'-', k)
                              overlapping_rsIDs[[i]][[1]][k, 2] <-  ifelse(str_detect(paste0(a[a$chr==i,][-k,'snp'][output[[i]][[k]]$yid,]), 'character'), NA , paste0(unlist(a[a$chr==i,][-k,'snp'][output[[i]][[k]]$yid,]), collapse = '-'))
                              overlapping_rsIDs[[i]][[1]][k, 3] <-  paste0(as.character(a[a$chr==i, ][k,]$snp))
                          
                }
                
              #remove NA
              overlapping_rsIDs[sapply( overlapping_rsIDs , is.null)] <- NULL
                
                
              }
              
              
              # #prepare the list for merging
              for(i in (1:length(overlapping_rsIDs))){
                overlapping_rsIDs[[i]] <- overlapping_rsIDs[[i]][[1]]
              }
              
              #merge and return
              end_data  <-do.call(rbind, overlapping_rsIDs)
              return(end_data)
              
              
              } else {
              
              a <-as.data.table(input_a)
              b <- as.data.table(input_b)
              
              a$chr <- as.numeric(a$chr)
              a$start <- as.numeric(a$start)
              a$end <- as.numeric(a$end)
              
              b$chr <- as.numeric(b$chr)
              b$start <- as.numeric(b$start)
              b$end <- as.numeric(b$end)
              
              output <- list()
              overlapping_rsIDs <- list()
              
                    for(i in c(1:n_chr)){
                      setkey(b,start, end)
                      output[[i]] <- foverlaps(a[a$chr==i,], b[b$chr==i,], type = 'any', which = TRUE, nomatch =NULL)
                      names(output)[[i]] <- paste0('CHR',i)
                      
                      #return the ovelapping SNPs
                      overlapping_rsIDs[[i]] <- input_b[output[[i]]$yid, 'SNP' ]
                      
                    }
              
              #return the overlapping loci defined by rsIDs
              return(overlapping_rsIDs)   
              
        }
            
  
  
}


```

## test_overlap_each

This function test the overlapp between two datasets. You need to provide the two datasest and the number of chromosomes where you want to perform the overalpp test. It expects the columns to be named CHR, start, end. It outputs a vector of overlapping loci. 
By selection auto_overlapp==T you provide just one dataset and the function will search for the overlapp inside the dataset. The function will return a list of SNP with their respective overlap. 
the iteration counter will be an indicator of the chromosome. 
This version of the function will return each interaction only once!!!! Because once the SNP has been tested, it's then taken out from the dataset. 

```{r test_overlap_each}
test_overlap_each <-function(input_a, input_b=NA, auto_overlapp=F){     
  require(data.table)
  require(stringr)
  
  if(auto_overlapp==T){ 
    
    #allocate the lists
    output <- list()
    colnames(input_a) <- tolower(colnames(input_a))
    overlapping_rsIDs <- list()
    
    #loop through each chromosome 
    for(i in c(unique(as.numeric(input_a$chr)))){
      #make sure everyhting is numeric
      a <-as.data.table(input_a)
      b <- as.data.table(input_a)
      
      a$chr <- as.numeric(a$chr)
      a$start <- as.numeric(a$start)
      a$end <- as.numeric(a$end)
      
      #allocate the lists
      overlapping_rsIDs[[i]] <-  list()
      overlapping_rsIDs[[i]][[1]] <- data.frame('iteration'=NA,'Overlapp_with_query'=NA,'Query_SNP'=NA)
      output[[i]] <- list()
      
      #loop for checking the overlapp between each element and the rest of the list
      for(k in c(1:nrow(a[a$chr==i, ]))){
        
        output[[i]][[k]] <- list()
        
        #select the SNP dataset to compare
        test_SNP <- as.data.table(a[a$chr==i, ][1,])
        test_SNP$chr<- as.numeric(test_SNP$chr)
        test_SNP$start<- as.numeric(test_SNP$start)
        test_SNP$end<- as.numeric(test_SNP$end)
        
        group_b <- as.data.table(a[a$chr==i,][-1,])
        group_b$chr <- as.numeric(group_b$chr)
        group_b$start <- as.numeric(group_b$start)
        group_b$end <- as.numeric(group_b$end)
        
        setkey(group_b,start, end)
        output[[i]][[k]] <- foverlaps(test_SNP, group_b, type = 'any', which = TRUE, nomatch =NULL)
        
        #put the results in a list
        overlapping_rsIDs[[i]][[1]][k, 1] <-  paste0(i,'-', k)
        overlapping_rsIDs[[i]][[1]][k, 2] <-  ifelse((length(output[[i]][[k]]$yid) == 0) , NA , paste0(unlist(group_b[output[[i]][[k]]$yid,'snp']), collapse = '-'))
        overlapping_rsIDs[[i]][[1]][k, 3] <-  paste0(as.character(test_SNP$snp))
        
        a <-   a[!a$snp==test_SNP$snp, ]
        
      }
      
      #remove NA
      overlapping_rsIDs[sapply( overlapping_rsIDs , is.null)] <- NULL
      
      
    }
    
    
    # #prepare the list for merging
    for(i in (1:length(overlapping_rsIDs))){
      overlapping_rsIDs[[i]] <- overlapping_rsIDs[[i]][[1]]
    }
    
    #merge and return
    end_data  <-do.call(rbind, overlapping_rsIDs)
    return(end_data)
    
    
  } else {
    
    a <-as.data.table(input_a)
    b <- as.data.table(input_b)
    
    a$chr <- as.numeric(a$chr)
    a$start <- as.numeric(a$start)
    a$end <- as.numeric(a$end)
    
    b$chr <- as.numeric(b$chr)
    b$start <- as.numeric(b$start)
    b$end <- as.numeric(b$end)
    
    output <- list()
    overlapping_rsIDs <- list()
    
    for(i in c(1:22)){
      overlapping_rsIDs[[i]] <-  list()
      overlapping_rsIDs[[i]][[1]] <- data.frame('iteration'=NA,'SNP_A'=NA,'SNP_B'=NA)
      
      
      setkey(b,start, end)
      output[[i]] <- foverlaps(a[a$chr==i,], b[b$chr==i,], type = 'any', which = TRUE, nomatch =NULL)
      names(output)[[i]] <- paste0('CHR',i)
      
      #save the overlapping
      overlapping_rsIDs[[i]][[1]] <- data.frame(
        'iteration'=rep(i, length(output[[i]]$yid)),
        'SNP_input_a'=input_a[output[[i]]$xid, 'SNP' ],
        'SNP_input_b'= input_b[output[[i]]$yid, 'SNP' ]
      ) 
      #keep truck of the iteration that return a positive hit
      index[i] <- (length(output[[i]]$yid) > 0)
      
    }
    
    end_data <- list()
    
    #prepare for return
    for(q in c(1:length(overlapping_rsIDs[c(index)])) ){
      end_data[[q]] <- overlapping_rsIDs[c(index)][[q]][[1]]
    }
    
    #merge and return
    end_data  <-do.call(rbind, end_data)
    return(end_data)
    
    
  }
  
}

```

##prepare_plot

a functio to prepare sumary stats to be plotted

```{r prepare_plot}
prepare_plot <-  function(res, Pval_col,plimit=0.005, BP='BP', CHR='CHR') {
  require(dplyr)
  res[,Pval_col] <- as.numeric(res[, Pval_col])
  res[, CHR] <- as.numeric(res[, CHR])
  res <- res[res[, CHR] %in% c(1:22),]
  output <- res[(which(!is.na(res[,Pval_col]))),]
  output <- output[which(output[, Pval_col] <  plimit),]
  output <- rename(output, BP=all_of(BP), CHR=all_of(CHR), p=all_of(Pval_col) )
  return(output)
}
```


## create_range
This function creates a genomic ranges object. It accepts a dataframe (res)

```{r create_range}
create_range <- function(res, chr='CHR', start='start', end='end', w=T, tag=NA ) {
  #require(GenomicRanges)
  obj <-GRanges( seqnames =  res$chr ,IRanges(names = res$chr ,start = as.numeric(res$start), end = as.numeric(res$end))) 
  if( sum(obj@ranges@width> 2000000) >0 ) { warning(paste0( sum(obj@ranges@width> 2000000)) ,' ranges are wider than 2 MB') 
    print(obj[which(obj@ranges@width> 2000000),])
  }
  ifelse(w, return(obj), return(data.frame(names= obj@ranges@NAMES ,start=obj@ranges@start, width=obj@ranges@width))) 
  
}
```

## locus lister
this function identifies significant loci with the locus.breaker fuction
then creates a table of all the loci for all traits and puts them togehter.
then looks at the overlapps between the loci and creates a macro loci that do not overlapp among them and assigns them a unique number (column pan_loci)
the function requires the sumstatst have the columns: SNP, CHR,BP, A2 (EFFECT_ALLELE), A1 (NON_EFFECT_ALLELE), BETA,SE, P. 
The functions locus.breaker adn create_range must be loaded. 
My paths must be a list of paths, and gwas names must be a list of names of the gwas ordered a my_paths. Run the function with commented lines for packages as sometimes when loading the package into the function caused errors.  


```{r locus_lister}


locus_lister <- function(my_paths, gwas_names) {
  # require(data.table)
  # require(dplyr)
  # require(GenomicRanges)
  
  SNPs <- list()
  list_of_files <- list()

  for( i in c(1:length(my_paths))){
    #load the sumstats and put them into a list
    list_of_files[[i]] <- fread(my_paths[[i]], data.table = F)
    SNPs[[i]]<- list_of_files[[i]]$SNP
  }
  
  shared_SNPs <- Reduce(intersect, SNPs) #compute the SNPs that are present in all the summary stats
  names(list_of_files) <- unlist(gwas_names)
  loci <- list()
  
  for(i in c(1:length(my_paths))){
            to_take <- gwas_names[[i]]
            sstats <- list_of_files[[to_take]]
            colnames(sstats) <- toupper(colnames(sstats))
            
            sstats <- select(sstats, c(SNP, CHR,BP, A2, A1, BETA,SE, P))
            sstats <- sstats[sstats$SNP %in% shared_SNPs,] #select only the SNPs that are shared among all the traits
            loci[[i]] <-  locus.breaker(sstats)  #locus breaker function is in my R profile
            loci[[i]]$trait <- rep(to_take, nrow(loci[[i]]))
  }
  
  all_loci <- do.call(rbind, loci) #create the listof all the loci
  
  pan_loci <- reduce(create_range(all_loci)) #create the genomic ranges object with my function create_range
  pan_loci_non_reduced <- create_range(all_loci)
  
  overlapping <- findOverlaps(pan_loci_non_reduced, pan_loci) #find overlaps between all the loci and use it as an index of the unique non overlapping loci
  all_loci$pan_locus <- rep(0, nrow(all_loci)) #allocate the column 
  all_loci[overlapping@from,]$pan_locus <- overlapping@to  #assinging the number as index of which macro loci is overlapping 
  
  return(all_loci)
  
}
```

## locus lister_2

```{r locus_lister_2}
locus_lister_2 <- function(my_paths, gwas_names) {
  # require(data.table)
  # require(dplyr)
  # require(GenomicRanges)
  
  SNPs <- list()
  list_of_files <- list()

  for( i in c(1:length(my_paths))){
    #load the sumstats and put them into a list
    list_of_files[[i]] <- fread(my_paths[[i]], data.table = F)
    SNPs[[i]]<- list_of_files[[i]]$SNP
  }
  
  shared_SNPs <- Reduce(intersect, SNPs) #compute the SNPs that are present in all the summary stats
  names(list_of_files) <- unlist(gwas_names)
  loci <- list()
  
  for(i in c(1:length(my_paths))){
            to_take <- gwas_names[[i]]
            sstats <- list_of_files[[to_take]]
            colnames(sstats) <- toupper(colnames(sstats))
            
            sstats <- select(sstats, c(SNP, CHR,BP, A2, A1, BETA,SE, P))
            sstats <- sstats[sstats$SNP %in% shared_SNPs,] #select only the SNPs that are shared among all the traits
            loci[[i]] <-  locus.breaker(sstats)  #locus breaker function is in my R profile
            loci[[i]]$trait <- rep(to_take, nrow(loci[[i]]))
  }
  
  all_loci <- do.call(rbind, loci) #create the listof all the loci
  
  pan_loci <- reduce(create_range(all_loci)) #create the genomic ranges object with my function create_range
  pan_loci_non_reduced <- create_range(all_loci)
  
  overlapping <- findOverlaps(pan_loci_non_reduced, pan_loci) #find overlaps between all the loci and use it as an index of the unique non overlapping loci
  overlapping
  all_loci$pan_locus <- rep(0, nrow(all_loci)) #allocate the column 
  all_loci[overlapping@from,]$pan_locus <- overlapping@to  #assinging the number as index of which macro loci is overlapping 
  
  return(all_loci)
  
}
```


## colocalize

This function takes as input a list of paths to munged summary statistics, thir repsectivr trait names(in list format). An output from locu_lister. 

```{r colocalize}
colocalize <- function(list_of_paths, trait_names, loci){
    #packages 
    # require(data.table)
    # require(dplyr)
    # require(GenomicRanges)
    # require(hyprcoloc)

    SNPs <- list()
    list_of_files <- list()
    
    for( i in c(1:length(trait_names))){
            #load the sumstats and put them into a list
            list_of_files[[i]] <- fread(list_of_paths[[i]], data.table = F)
            SNPs[[i]]<- list_of_files[[i]]$SNP
    }
    
    names(list_of_files) <- unlist(trait_names)
    #start by searching the commong SNPs between all the gwas and generate a referenc set 
    shared_SNPs <- Reduce(intersect, SNPs) 
    cat(paste0('The number of shared SNPs is ', length(shared_SNPs )))
    
    reference_file <- fread('SNP/reference.1000G.maf.0.005.txt.gz', data.table = F) #load the reference file
    ref_set <- reference_file[reference_file$SNP   %in%  shared_SNPs, ] #create a reference set of the positions of the shared SNPs
    loc_index <- sort(unique(loci$pan_locus))
    
    betas <- list()
    SE <- list()
    res_coloc <- list()
    report <- data.frame(row.names = paste0('locus_', loc_index )  ) #allocate space to produce a report of the number of SNPs per locus
    
    for(i in c(1:length(unique(loci$pan_locus)))){
      
            #select the active locus, the beginning and the end of the locus
            start_loc <- min(loci[loci$pan_locus==loc_index[i], 'start'] )
            end_loc <- max(loci[loci$pan_locus==loc_index[i], 'end'] )
            chr_loc <- unique(loci[loci$pan_locus==loc_index[i], 'chr'])
            
            #the active SNP for locus i
            SNP_active <- ref_set[c( between(ref_set$BP,  start_loc ,  end_loc)  & ref_set$CHR== chr_loc ), ]$SNP
            
            #if there are less than 10 SNPs raise the window of SNPs to take of +-100 kb 
            if(length(SNP_active)<10) {
                      start_loc_2 <-  as.numeric(ifelse((as.numeric(start_loc) - 100000)<0, 0, as.numeric(start_loc) - 100000 )) #not below zero 
                      end_loc_2 <- as.numeric(as.numeric(end_loc) + 100000 )
                      #select the active SNPs
                      SNP_active <- ref_set[c( between(ref_set$BP,  start_loc_2 ,  end_loc_2)  & ref_set$CHR== chr_loc ), ]$SNP
            } else {
                      #select the active SNPs
                      SNP_active <- ref_set[c( between(ref_set$BP,  start_loc ,  end_loc)  & ref_set$CHR== chr_loc ), ]$SNP
            }
            
            #allocate the space
            beta_locus <- data.frame(row.names =SNP_active )
            se_locus <- data.frame(row.names =SNP_active )
            
            #for each GWAS take out the BETAs and the SE
            for(k in c(1:length(unlist( loci[loci$pan_locus==i,]$trait)))){
                        #take only the ones that are significant fot that loci
                        tt<- unlist( loci[loci$pan_locus==i,]$trait)[k] 
                        tr_SNP_active <- list_of_files[[tt]][ list_of_files[[tt]]$SNP %in% SNP_active ,]
                        tr_SNP_active <- tr_SNP_active[!duplicated(tr_SNP_active ), ] #remove duplicated SNPs 
                        #exctract the betas and se
                        beta_locus[, paste0(tt,'-',k,'_locus', i)] <- select(tr_SNP_active, 'BETA')
                        se_locus[, paste0(tt,'-',k,'_locus', i)] <- select(tr_SNP_active, 'SE')
                
            }
            
            #run coloc only if the number of traits for that locus is more than one (otherwise you will have an error) and if there are at least 10 SNPs
            if(ncol(beta_locus)>1 & nrow(beta_locus)>10){
                        traits <- colnames(beta_locus)
                        rsid <- rownames(beta_locus)
                        res_coloc[[paste0('locus_', i)]] <- hyprcoloc( effect.est = as.matrix(beta_locus), effect.se = as.matrix(se_locus), trait.names=traits, snp.id=rsid, binary.outcomes = rep(1, length(traits)))
            
            } 
            
            betas[[paste0('locus_', i)]] <- beta_locus
            SE[[paste0('locus_', i)]] <- se_locus
            report[i,'SNP_active'] <-  length(SNP_active) 
            report[i,'traits'] <- paste0(loci[loci$pan_locus==i,]$trait, collapse = ',')
            print(i)
    }  

    
    output <- list(betas=betas, SE=SE, res_coloc=res_coloc, report=report) 
    return(output)
}

```

## colocalize_2

Runs hyprcoloc on all the loci withouth checking if they are physically overlapping
```{r colocalize_2}
colocalize_2 <- function(list_of_paths, trait_names, loci){
  #packages 
  # require(data.table)
  # require(dplyr)
  # require(GenomicRanges)
  # require(hyprcoloc)
  
    SNPs <- list()
    list_of_files <- list()
    
    for( i in c(1:length(trait_names))){
      #load the sumstats and put them into a list
      list_of_files[[i]] <- fread(list_of_paths[[i]], data.table = F)
      SNPs[[i]]<- list_of_files[[i]]$SNP
    }
    
    names(list_of_files) <- unlist(trait_names)
    #start by searching the commong SNPs between all the gwas and generate a referenc set 
    shared_SNPs <- Reduce(intersect, SNPs) 
    cat(paste0('The number of shared SNPs is ', length(shared_SNPs )))
    
    reference_file <- fread('SNP/reference.1000G.maf.0.005.txt.gz', data.table = F) #load the reference file
    ref_set <- reference_file[reference_file$SNP   %in%  shared_SNPs, ] #create a reference set of the positions of the shared SNPs
    loc_index <- sort(unique(loci$pan_locus))
    
    betas <- list()
    SE <- list()
    res_coloc <- list()
    report <- data.frame(row.names = paste0('locus_', loc_index )  ) #allocate space to produce a report of the number of SNPs per locus
    
    for(i in c(1:length(unique(loci$pan_locus)))){
      
      #select the active locus, the beginning and the end of the locus
      start_loc <- min(loci[loci$pan_locus==loc_index[i], 'start'] )
      end_loc <- max(loci[loci$pan_locus==loc_index[i], 'end'] )
      chr_loc <- unique(loci[loci$pan_locus==loc_index[i], 'chr'])
      
      #the active SNP for locus i
      SNP_active <- ref_set[c( between(ref_set$BP,  start_loc ,  end_loc)  & ref_set$CHR== chr_loc ), ]$SNP
      
      #if there are less than 10 SNPs raise the window of SNPs to take of +-100 kb 
      if(length(SNP_active)<10) {
        start_loc_2 <-  as.numeric(ifelse((as.numeric(start_loc) - 100000)<0, 0, as.numeric(start_loc) - 100000 )) #not below zero 
        end_loc_2 <- as.numeric(as.numeric(end_loc) + 100000 )
        #select the active SNPs
        SNP_active <- ref_set[c( between(ref_set$BP,  start_loc_2 ,  end_loc_2)  & ref_set$CHR== chr_loc ), ]$SNP
      } else {
        #select the active SNPs
        SNP_active <- ref_set[c( between(ref_set$BP,  start_loc ,  end_loc)  & ref_set$CHR== chr_loc ), ]$SNP
      }
      
      #allocate the space
      beta_locus <- data.frame(row.names =SNP_active )
      se_locus <- data.frame(row.names =SNP_active )
      
      #for each GWAS take out the BETAs and the SE
      for(k in c(1:length(list_of_files))){
        #take all of them
        tt<- unlist(trait_names)[k] 
        tr_SNP_active <- list_of_files[[tt]][ list_of_files[[tt]]$SNP %in% SNP_active ,]
        tr_SNP_active <- tr_SNP_active[!duplicated(tr_SNP_active ), ] #remove duplicated SNPs 
        #exctract the betas and se
        beta_locus[, paste0(tt,'-',k,'_locus', i)] <- select(tr_SNP_active, 'BETA')
        se_locus[, paste0(tt,'-',k,'_locus', i)] <- select(tr_SNP_active, 'SE')
        
      }
      
      #run coloc only  if there are at least 10 SNPs
      if( nrow(beta_locus)>10){
        traits <- colnames(beta_locus)
        rsid <- rownames(beta_locus)
        res_coloc[[paste0('locus_', i)]] <- hyprcoloc( effect.est = as.matrix(beta_locus), effect.se = as.matrix(se_locus), trait.names=traits, snp.id=rsid, binary.outcomes = rep(1, length(traits)))
  
    } 
      
      betas[[paste0('locus_', i)]] <- beta_locus
      SE[[paste0('locus_', i)]] <- se_locus
      report[i,'SNP_active'] <-  length(SNP_active) 
      report[i,'traits'] <- paste0(loci[loci$pan_locus==i,]$trait, collapse = ',')
      print(i)
  }  
    
  
  output <- list(betas=betas, SE=SE, res_coloc=res_coloc, report=report) 
  return(output)
  }

```


## molocalize
a function that takes as input the locus lister output and runs moloc (https://github.com/clagiamba/moloc) on the loci that are overlappig

```{r molocalize}
molocalize <- function(list_of_paths, trait_names, loci, N_hat){
      #packages 
      # require(data.table)
      # require(dplyr)
      # require(GenomicRanges)
      # require(hyprcoloc)
      
      SNPs <- list()
      list_of_files <- list()
      
      for( i in c(1:length(trait_names))){
                #load the sumstats and put them into a list
                list_of_files[[i]] <- fread(list_of_paths[[i]], data.table = F)
                SNPs[[i]]<- list_of_files[[i]]$SNP
              }
              
      names(list_of_files) <- unlist(trait_names)
              #start by searching the commong SNPs between all the gwas and generate a referenc set 
      shared_SNPs <- Reduce(intersect, SNPs) 
      cat(paste0('The number of shared SNPs is ', length(shared_SNPs )))
              
      reference_file <- fread('SNP/reference.1000G.maf.0.005.txt.gz', data.table = F) #load the reference file
      ref_set <- reference_file[reference_file$SNP   %in%  shared_SNPs, ] #create a reference set of the positions of the shared SNPs
      loc_index <- sort(unique(loci$pan_locus))
              
      betas <- list()
      SE <- list()
      res_coloc <- list()
      report <- data.frame(row.names = paste0('locus_', loc_index )  ) #allocate space to produce a report of the number of SNPs per locus
      lo <- list() 
      
      for(i in c(1:length(unique(loci$pan_locus)))){
                
                    #select the active locus, the beginning and the end of the locus
                    start_loc <- min(loci[loci$pan_locus==loc_index[i], 'start'] )
                    end_loc <- max(loci[loci$pan_locus==loc_index[i], 'end'] )
                    chr_loc <- unique(loci[loci$pan_locus==loc_index[i], 'chr'])
                    
                    #the active SNP for locus i
                    SNP_active <- ref_set[c( between(ref_set$BP,  start_loc ,  end_loc)  & ref_set$CHR== chr_loc ), ]$SNP
                    
                    #if there are less than 10 SNPs raise the window of SNPs to take of +-100 kb 
                    if(length(SNP_active)<10) {
                      start_loc_2 <-  as.numeric(ifelse((as.numeric(start_loc) - 100000)<0, 0, as.numeric(start_loc) - 100000 )) #not below zero 
                      end_loc_2 <- as.numeric(as.numeric(end_loc) + 100000 )
                      #select the active SNPs
                      SNP_active <- ref_set[c( between(ref_set$BP,  start_loc_2 ,  end_loc_2)  & ref_set$CHR== chr_loc ), ]$SNP
                    } else {
                      #select the active SNPs
                      SNP_active <- ref_set[c( between(ref_set$BP,  start_loc ,  end_loc)  & ref_set$CHR== chr_loc ), ]$SNP
                    }
                    
                    #allocate the space
                    the_locus <- data.frame(row.names = c(1:length(SNP_active)))
                    to_moloc <- list()
                    #for each GWAS take out the BETAs and the SE
                    for(k in c(1:length(unlist( loci[loci$pan_locus==i,]$trait)))){
                              #take only the ones that are significant fot that loci
                              tt<- unlist( loci[loci$pan_locus==i,]$trait)[k] 
                              tr_SNP_active <- list_of_files[[tt]][ list_of_files[[tt]]$SNP %in% SNP_active ,]
                              tr_SNP_active <- tr_SNP_active[!duplicated(tr_SNP_active ), ] #remove duplicated SNPs 
                              #exctract the betas and se
                              the_locus[, 'SNP'] <- SNP_active
                              the_locus[, 'BETA'] <- select(tr_SNP_active, 'BETA')
                              the_locus[, 'SE'] <- select(tr_SNP_active, 'SE')
                              the_locus[, 'MAF'] <- ref_set[ref_set$SNP %in% tr_SNP_active$SNP, ]$MAF
                              the_locus[, 'N'] <- rep(N_hat[[tt]], length(SNP_active))
                              to_moloc[[tt]] <- the_locus
                            
                            }
                    
                    #run coloc only if the number of traits for that locus is more than one (otherwise you will have an error) and if there are at least 10 SNPs
                    if(length(to_moloc)>1 & length(SNP_active)>10){
                      res_coloc[[paste0('locus_', i)]] <- moloc_test(to_moloc)
                      
                    } 
                    
                    lo[[paste0('locus_', i)]] <- to_moloc
                    report[i,'SNP_active'] <-  length(SNP_active)
                    report[i,'traits'] <- paste0(loci[loci$pan_locus==i,]$trait, collapse = ',')
                    print(i)
                  }
      
      
      output <- list(lo=lo, res_coloc=res_coloc, report=report) 
      return(output)
}
```




## lists_forupset
A function to prepare data from genomic ranges and return an object that can be run in create comb matrix
```{r list for upset}
lists_forupset <- function(ovl_f, traits){ 
  #allocate lists
  require(ComplexHeatmap)
  un <- list()
  final <- list(list())
  sh <- list()
  #create the lists and put it the eleemtnts that are unique
  for( i in 1:length(traits)){
    tt<-traits[i]
    filt <- str_starts(names(ovl_f$uniquePeaks@ranges),tt, negate = FALSE)
    un[[tt]] <- names(ovl_f$uniquePeaks@ranges)[filt]
  }
  
  #put into the lists the element that are shared among the lists
  for(k in 1:length(ovl_f$mergedPeaks$peakNames)){
    
    chek_in <- traits %in% substring(ovl_f$mergedPeaks$peakNames[[k]], first = 1, last = 2) #check if there is f1, f2 or f3
    
    for(u in 1:length(chek_in)){
      tt<-traits[u]
      if(chek_in[u]==T){
        un[[tt]][[length(un[[tt]])+1]]<- paste0(ovl_f$mergedPeaks$peakNames[[k]], collapse = '-')
      }
      
    }
  }
  
  #-generate a matrix showing which locus is present in each disease
  output <- list()
  for(k in 1:length(un)){
    tt <- c(names(un))[k]
    to_get <- strsplit(unlist(strsplit(un[[tt]], split = '-')), split='__')
    
    for(i in c(1:length(to_get))){
      output[[tt]][[i]]<-to_get[[i]][2]
      
    }
    output[[tt]]<- unlist(output[[tt]])
    
  }
  output <- list_to_matrix(output)
  output <- output[order(as.numeric(rownames(output))),]
  
  #generate the output
  return(list(loci=output, traits_overlap=un))
}

```

## plot locus genes
this function plots the genes in the genomic coordinates that are proved. It's base on build 37

```{r}
plot_locus_genes <- function(start, end, chr){
  require(Gviz)
  require(EnsDb.Hsapiens.v75)
  require(GenomicRanges)
  #retrieve the info on the genes
  ref_genes <- genes(EnsDb.Hsapiens.v75)
  ref_genes <- ref_genes[ref_genes@elementMetadata$gene_biotype=='protein_coding',]
  ind <- findOverlaps(GRanges(seqnames = chr ,IRanges(start = start, end = end)), ref_genes, type = 'any' )
  a <- ref_genes[ind@to,]
  #function for plotting
  granges2df <- function(x) {
    df <- as(x, "data.frame")
    df <- df[,c("seqnames","start","end","strand","group_name", 'exon_id')]
    colnames(df)[1] <- "chromosome"
    colnames(df)[5] <- "transcript"
    df
  }
  txdf <- select(EnsDb.Hsapiens.v75,
                 keys=keys(EnsDb.Hsapiens.v75, "GENEID"),
                 columns=c("GENEID","TXID", 'SYMBOL'),
                 keytype="GENEID")
  ebt <- exonsBy(EnsDb.Hsapiens.v75, by="tx")
  d <- list()
  for(i in 1:length(a@elementMetadata$gene_id)){
    idx <- txdf$GENEID ==  a@elementMetadata$gene_id[i]
    txs <- txdf$TXID[idx]
    #all the xons for these transcripts
    ebt2 <- ebt[txs]
    df <- granges2df(ebt2)
    df$gene <- a@elementMetadata$gene_id[i]
    df$symbol <-  txdf[match(df$gene, txdf$GENEID), ]$SYMBOL 
    d[[i]] <- df
  }
  d <- do.call(rbind, d) 
  grt <- GeneRegionTrack(d, showTitle=F, fill='black', background.title='white', size=0.5)
  #plot it
  #ideoTrack <- IdeogramTrack(genome = "hg19", chromosome = chr)
  axisTrack <- GenomeAxisTrack()
  plotTracks(c(axisTrack, grt) ,from = start, to = end, transcriptAnnotation="symbol", collapseTranscripts = 'longest', title.width=1,
             type=c('p'), lwd.grid=0.05
  )
}
```


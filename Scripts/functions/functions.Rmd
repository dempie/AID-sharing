---
title: "R Notebook"
output: html_notebook
---
In this notebook I will add the fucntion useful for this project that I have created or stolen from someone.

## prepare_munge

This function is useful to format GWAS summary statistic as the munge function from GenomicSEM wants them. 

```{r prepare_munge }
prepare_munge <- function(sum_stats, rsID, the_effect_allele, the_non_effect_allele, pvalue, effect_size, the_SE=NA, the_chr=NA, the_bp=NA, to_remove=NA, path = NA){
  #an error if arguments are not provided 
  if (missing(sum_stats) | missing(rsID) | missing(the_effect_allele) | missing(the_non_effect_allele) |missing(pvalue) | missing(effect_size) ) {
    stop( 'At least one argument is missing')
    
      } else {
        
          require(dplyr)
          require(data.table)
          sum_stats <- sum_stats  %>% rename(c(SNP = rsID, A1 = all_of(the_effect_allele), A2 = all_of(the_non_effect_allele), p = all_of(pvalue), effect = all_of(effect_size)))
          sum_stats$SNP <- tolower(sum_stats$SNP)
          sum_stats$p <- as.numeric(sum_stats$p)
          sum_stats$effect <- as.numeric(sum_stats$effect)
          
          #conditional options 
                #remove columns
                if(!is.na(to_remove[1])){sum_stats <- select(sum_stats,-(all_of(to_remove)))} 
                      
                #rename SE column
                if(!is.na(the_SE)){ 
                      sum_stats <- rename(sum_stats, SE=all_of(the_SE))
                      sum_stats$SE <- as.numeric(sum_stats$SE)
                      }
              
                #rename the CHR column
                if(!is.na(the_chr)){ sum_stats <-  rename(sum_stats, CHR=all_of(the_chr))}
              
                #rename the BP column
                if(!is.na(the_bp)){ sum_stats <- rename(sum_stats, BP=all_of(the_bp))}
          
                #save the file if a path is provided
                if(is.na(path)){
                    invisible(sum_stats)
                  
                  
                } else {
                  
                  fwrite(sum_stats, path, sep = '\t', col.names = T, row.names = F, quote = F)
                  invisible(sum_stats)
                }
              }
}

```


## qc_summary_stats 
takes as output of prepare_munge and outputs the number of SNP with rsID, 
```{r qc summary stats}
qc_summary_stats <- function(sum_stats, plots=F){
          #compute number of SNPs
          n_SNPs <- nrow(sum_stats)
          
          #compute the number of unique rsIDs 
          sum_stats_rsIDs<- sum_stats[grep('rs',sum_stats$SNP),]
          n_rsIDs <- length(unique(sum_stats_rsIDs$SNP))
          
          SNP_per_chr <- vector(mode='integer', length = 22)
          rsID_per_chr <-  vector(mode='integer', length = 22)
          
          #compute the number of unique rsIDs and SNPs per chromosome 
          for(i in c(1:22)){
            
                SNP_per_chr[i] <- nrow(sum_stats[sum_stats$CHR== i ,]) 
                rsID_per_chr[i] <- length(unique(sum_stats_rsIDs[sum_stats_rsIDs$CHR == i, ]$SNP))
          }
          
          qc_metrics_SNPs <- cbind(Chromosome = c(1:22) ,n_SNPs = SNP_per_chr )
          qc_metrics_rsIDs <- cbind(Chromosome = c(1:22) ,n_rsIDs = rsID_per_chr )
          
          cat(paste0( 'Total number of SNP  ' , n_SNPs , '\n', 
                      'Total number of SNP with rsID  ', n_rsIDs, '\n')
          )
          
          output <- list(qc_SNPs = qc_metrics_SNPs, qc_rsIDs=qc_metrics_rsIDs )
          
          
          
          if(plots==T){

            barplot(t(output$qc_SNPs) , main = 'Number of unique rsID per chromosome',  ylab = 'Number of SNP', 
                    names.arg = k$qc_SNPs[,1], cex.names = 0.8, 
                    legend.text =  paste0( 'Total number of SNP with rsID  ', n_rsIDs))
          }
          
          return(output)   
          
}
```


## semPlotModel_GSEM

This function transforms the output from genomic sem in an object that can be used by the semPlot function to draw paths for factor analysis representation. 
```{r semPlotModel_GSEM}
semPlotModel_GSEM=function(gsem.object=GWISoutput , est.label="STD_All"){ 
  require(semPlot)
  object=gsem.object$results
  object$free=0
  numb=1:length(which(object$op!="~~"))
  object$free[which(object$op!="~~")]=numb
  varNames <- lavaanNames(object, type = "ov")
  factNames <- lavaanNames(object, type = "lv")
  factNames <- factNames[!factNames %in% varNames]
  n <- length(varNames)
  k <- length(factNames)
  if (is.null(object$label)) 
    object$label <- rep("", nrow(object))
  semModel <- new("semPlotModel")
  object$est <- object[,est.label]
  if (is.null(object$group)) 
    object$group <- ""
  semModel@Pars <- data.frame(label = object$label, lhs = ifelse(object$op == 
                                                                   "~" | object$op == "~1", object$rhs, object$lhs), edge = "--", 
                              rhs = ifelse(object$op == "~" | object$op == "~1", object$lhs, 
                                           object$rhs), est = object$est, std = NA, group = object$group, 
                              fixed = object$free==0, par = object$free, stringsAsFactors = FALSE)
  semModel@Pars$edge[object$op == "~~"] <- "<->"
  semModel@Pars$edge[object$op == "~*~"] <- "<->"
  semModel@Pars$edge[object$op == "~"] <- "~>"
  semModel@Pars$edge[object$op == "=~"] <- "->"
  semModel@Pars$edge[object$op == "~1"] <- "int"
  semModel@Pars$edge[grepl("\\|", object$op)] <- "|"
  semModel@Thresholds <- semModel@Pars[grepl("\\|", semModel@Pars$edge), 
                                       -(3:4)]
  semModel@Pars <- semModel@Pars[!object$op %in% c(":=", "<", 
                                                   ">", "==", "|", "<", ">"), ]
  semModel@Vars <- data.frame(name = c(varNames, factNames), 
                              manifest = c(varNames, factNames) %in% varNames, exogenous = NA, 
                              stringsAsFactors = FALSE)
  semModel@ObsCovs <- list()
  semModel@ImpCovs <- list()
  semModel@Computed <- FALSE
  semModel@Original <- list(object)
  return(semModel)
  
}
```


## split_sum_stats
This function is meant to seaprate GWAS summary statas in n chunks of x size, and then recover a specific chunk. This is usefull for running job arrays in the cluster. 

```{r split_sum_stats}
split_sum_stats <- function(summary_stats, chunk_size, which_chunk) {
  require(data.table)
  #give a number to the elements of the sum_states
  my_index <- seq_along(1: nrow(summary_stats))
  n <- nrow(summary_stats) 
  chunks <- rep(1:ceiling(n/chunk_size),each=chunk_size)[1:n] #the last piece [1:n] is necessary because otherwise the last chunk will become long as the chunk size and will replicate it thus exciding the length of the sumstats
  a <- split(my_index, chunks)
  summary_stats[ (a[[which_chunk]]) , ]
}
```


## is_se_logB
This function is for checking if the standard error reported in GWAS summary stats is a standard error of logistic beta. If the calculated and reported are almost identical that it is a selogB.  It plots 10000 randomly selected pvalues andruns a linear model between pcalcualte and reported. I look at the r squared from the linea regression. If >0.99 than we can confidently say the pvalues are identical and thus we are looking at a SE of log(beta)

```{r is_se_logB}
is_se_logB <- function(BETA,SE, PVALUE) {
  p_calculated <- 2*pnorm((abs(BETA) / SE),lower.tail = F)
  p_reported <- PVALUE
  #data.frame(p_calculated, p_reported), 
  a <- lm(p_calculated~p_reported) #fit a linear model to see if they are perfectly correlated 
  print(summary(a))
  
  rand <- sample(1:length(BETA), 10000)
  plot(p_reported[rand], p_calculated[rand]) 
  abline(a, col="red") # regression line (y~x)
  abline(0, 1, col='blue', lty= 4 )
}

```


## calculate_prevalence

A function to calculate the sanple prevalence from a csv which has three columns: consortium, cases, controls. 

https://github.com/GenomicSEM/GenomicSEM/wiki/2.1-Calculating-Sum-of-Effective-Sample-Size-and-Preparing-GWAS-Summary-Statistics
```{r calculate_prevalence}
locus.breaker=function(res,p.sig=5e-8, p.limit=1e-5,hole.size=250000
                       ,p.label="p",chr.label="chr",pos.label="pos"){
  
  res = res[order(as.numeric(res[, chr.label]), as.numeric(res[,pos.label])),]
  
  res=res[which(res[,p.label]<p.limit),]
  trait.res=c()
  for(j in 1:22){
    
    res.chr=res[which(res[,chr.label]==j),]
    if(nrow(res.chr)>1){
      holes=res.chr[,pos.label][-1]-res.chr[,pos.label][-length(res.chr[,pos.label])] 
      gaps=which(holes>hole.size)
      if(length(gaps)>0){
        for(k in 1:(length(gaps)+1)){
          
          if(k==1){
            res.loc=res.chr[1:(gaps[k]),]  
          }else if(k==(length(gaps)+1)){
            res.loc=res.chr[(gaps[k-1]+1):nrow(res.chr),]  
          }else{
            res.loc=res.chr[(gaps[k-1]+1):(gaps[k]),]
          }
          if(min(res.loc[,p.label])<p.sig){
            
            start.pos=min(res.loc[,pos.label],na.rm=T)
            end.pos=max(res.loc[,pos.label],na.rm=T)
            chr=j
            best.snp=res.loc[which.min(res.loc[,p.label]),]
            line.res=c(chr,start.pos,end.pos,unlist(best.snp))
            trait.res=rbind(trait.res,line.res)
          }
          
          
        }
      }else{
        res.loc=res.chr
        if(min(res.loc[,p.label])<p.sig)  {
          
          start.pos=min(res.loc[,pos.label],na.rm=T)
          end.pos=max(res.loc[,pos.label],na.rm=T)
          chr=j
          best.snp=res.loc[which.min(res.loc[,p.label]),]
          line.res=c(chr,start.pos,end.pos,unlist(best.snp))
          trait.res=rbind(trait.res,line.res)
        }
        
      }
      
    }else if(nrow(res.chr)==1){
      
      res.loc=res.chr
      if(min(res.loc[,p.label])<p.sig){
        start.pos=min(res.loc[,pos.label],na.rm=T)
        end.pos=max(res.loc[,pos.label],na.rm=T)
        chr=j
        best.snp=res.loc[which.min(res.loc[,p.label]),]
        line.res=c(chr,start.pos,end.pos,unlist(best.snp))
        trait.res=rbind(trait.res,line.res)
      }
      
      
    }
  }
  
  print(trait.res)
  trait.res=as.data.frame(trait.res,stringsAsFactors=FALSE)
  trait.res=trait.res[,-(which(names(trait.res)==chr.label))]
  names(trait.res)[1:3]=c("chr","start","end")
  trait.res
}
```

## assemble_3f 

This function take a list of chunks and returns a list in which each of the elements is the complete and assemble summary stats for each of the factors. You provide the number of factors estimanted and the fucntion will create as many summary statistics as there are factors.  
The function check the existence of the chunks, returns a warning indicating which chunks are missing and loads then ones that are not missing. That separetes according to the factor and outputs info about the unique number of SNPs per factor and the number of SNPs not estimated. The returning object is a list of summary statistics.
The input= number of expceted chunks is the index of the chunks. 

```{r assemble_3f function}

assemble_f <- function(n_expected_chunks, first_part_of_path, terminal_part_of_path, n_factors ){
  
  
      n_expected_chunks <- c(n_expected_chunks)
        
      #check if files exist and return the one that do not exist
      chunks_found <- lapply(c(n_expected_chunks), function(x)file.exists(paste0(first_part_of_path, x, terminal_part_of_path)))
      missing_chunks <- c(n_expected_chunks)[unlist(chunks_found)==F]
      
        #issue a warning indicating which chunks are missing and that will not be included in the final sumstats
            if((length(missing_chunks))>0) { 
              
              warning(    paste0('SOME CHUNKS ARE MISSING!', '\n',
                          length(n_expected_chunks) - length(missing_chunks), ' chunks were found!', '\n',
                          length(missing_chunks), ' chunks were NOT found!', '\n',
                          'The missing chunks are the ', paste0(missing_chunks, collapse = ' - ') , '\n', 
                          '\n')
                      )
              
            } else {
              
              cat(paste0( length(chunks_found) , ' chunks were found!', '\n', 
                          'There are not missing chunks :) ','\n' ,
                          '\n' ))
            }
      
      
      #load the chunks that have been found
      chunks_to_load <-  c(n_expected_chunks)[unlist(chunks_found)==T]
      
      chunks <- lapply( chunks_to_load , function(x)readRDS(paste0(first_part_of_path, x, terminal_part_of_path )))
      
      cat(paste0('I have loaded ' , length(chunks), ' chunks!', '\n'))
      
      #for each chunk, separate the factors and merge the chunk for each factor
      #allocate the list
      ordered <- list()
      sum_stats <- list()
      
      #cycle through each of the factors (n_factors)
      for(k in c(1:n_factors)) {
        
                #allocate a list in the k element of ordered according to the number of factors
                ordered[[k]] <- list()
                #separate the Factors in the ordered list
                for(i in (1:length(chunks))){
                       ordered[[k]][[i]] <- chunks[[i]][[k]]
                }
                
                #merge the chunks for each facotr, put into a list a name the element of the list
                sum_stats[[k]] <-  do.call(rbind, ordered[[k]]) 
                names(sum_stats)[k] <- paste0('factor', k)
                
                #issue a warning if the number of unique SNP is less then the number of rows
                if( length(unique(sum_stats[[k]]$SNP))!= nrow(sum_stats[[k]]) ){warning('The number of unique SNP is different than the number of rows in F',k ,'!!!' )}
                
                #issue a warning if the cumulative numnber of unique SNPs in the merged dataset is different from the sum of the individual unique SNPs per chunk
                if( nrow(sum_stats[[k]]) != sum(unlist(lapply(ordered[[k]], nrow)))  )  warning('The number of unique SNP is different between the merged and the sum of the individual chunks in F',k,  '!!!')
        
      }
      
      #calculate some useful qc information
        SNPs_unique <- list()
        SNP_error <- list()
      
        qc_info <- for( i in (1:length(sum_stats))){
        
            #number of SNP in total without error
            SNPs_unique[[i]]  <- cat(paste0('The number of unique SNPs in F',i, ' is ', length(unique(sum_stats[[i]]$SNP)), '\n'))
            
            #operator found
            cat('The lhs operators found in F',i, ' are ',  unique(sum_stats[[i]]$lhs), '\n')
            
            #number of SNP not estimated
            SNP_error[[i]] <-  cat(paste0('The number of not estimated SNPs in F', i , ' is ', nrow(sum_stats[[i]][sum_stats[[i]]$error != 0,]), '\n' , 
                                          '\n'))
            
        }
      
      
      invisible(sum_stats)
}

```


## append chunk

This funciton will merge chunks that are coming out the assemble_3 chunks. Important to provde a list of chunks were the elements of the list are list of summary stats for each factor of summary statistics. It issues a warning if something is messed up 
You need to provide the number of facotrs estimated. 
```{r append chunk}
#it takes the output of the aseemble_3f function,
#  
# REMBER TO remove all the accesory outputs from assemble_3f

append_chunk <- function(list_complete, n_factors ){
    
    #allocate list
    ordered <- list()
    sum_stats <- list()
    
    #cycle through each of the factors (n_factors)
    for(k in c(1:n_factors)) {
      
                #allocate a list in the k element of ordered according to the number of factors
                ordered[[k]] <- list()
                #separate the Factors in the ordered list
                for(i in (1:length(list_complete))){
                  ordered[[k]][[i]] <- list_complete[[i]][[k]]
                }
                
                #merge the chunks for each facotr, put into a list a name the element of the list
                sum_stats[[k]] <-  do.call(rbind, ordered[[k]])
                names(sum_stats)[k] <- paste0('factor', k)

                #issue a warning if the number of unique SNP is less then the number of rows
                if( length(unique(sum_stats[[k]]$SNP))!= nrow(sum_stats[[k]]) ){warning('The number of unique SNP is different than the number of rows in F',k ,'!!!' )}

                #issue a warning if the cumulative numnber of unique SNPs in the merged dataset is different from the sum of the individual unique SNPs per chunk
                if( nrow(sum_stats[[k]]) != sum(unlist(lapply(ordered[[k]], nrow)))  )  warning('The number of unique SNP is different between the merged and the sum of the individual chunks in F',k,  '!!!')

              }
    
    #calculate some useful qc information
    SNPs_unique <- list()
    SNP_error <- list()
    
    for( i in (1:length(sum_stats))){
      
                #number of SNP in total without error
                SNPs_unique[[i]]  <- cat(paste0('The number of unique SNPs in F',i, ' is ', length(unique(sum_stats[[i]]$SNP)), '\n'))
                
                #operator found
                cat('The lhs operators found in F',i, ' are ',  unique(sum_stats[[i]]$lhs), '\n')
                
                #number of SNP not estimated
                SNP_error[[i]] <-  cat(paste0('The number of not estimated SNPs in F',i, ' is ', nrow(sum_stats[[i]][sum_stats[[i]]$error != 0,]), '\n' , 
                                              '\n'))
      
    }
    
    
    invisible(sum_stats)
    
}

```

## test_overlap

This function test the overlapp between two datasets. You need to provide the two datasest and the number of chromosomes where you want to perform the overalpp test. It expects the columns to be named CHR, start, end. It outputs a vector of overlapping loci. 
By selection auto_overlapp==T you provide just one dataset and the function will search for the overlapp inside the dataset. The function will return a list of SNP with their respective overlap. 
the iteration counter will be an indicator of the chromosome. 



```{r test_overlap}
test_overlap <-function(input_a, input_b=NA, n_chr=NA, auto_overlapp=F){     
            require(data.table)
            require(stringr)
  
            if(auto_overlapp==T){ 
             
              #allocate the lists
              output <- list()
              colnames(input_a) <- tolower(colnames(input_a))
              overlapping_rsIDs <- list()
              
              #loop through each chromosome 
              for(i in c(unique(as.numeric(input_a$chr)))){
                      #make sure everyhting is numeric
                      a <-as.data.table(input_a)
                      b <- as.data.table(input_a)
                      
                      a$chr <- as.numeric(a$chr)
                      a$start <- as.numeric(a$start)
                      a$end <- as.numeric(a$end)
                      
                      #allocate the lists
                      overlapping_rsIDs[[i]] <-  list()
                      overlapping_rsIDs[[i]][[1]] <- data.frame('iteration'=NA,'Overlapp_with_query'=NA,'Query_SNP'=NA)
                      output[[i]] <- list()
                      
                      #loop for checking the overlapp between each element and the rest of the list
                      for(k in c(1:nrow(a[a$chr==i, ]))){
                  
                  
                              setkey(a,start, end)
                              output[[i]][[k]] <- foverlaps(a[a$chr==i, ][k,], a[a$chr==i,][-k,], type = 'any', which = TRUE, nomatch =NULL)
                              
                              #put the results in a list
                              overlapping_rsIDs[[i]][[1]][k, 1] <-  paste0(i,'-', k)
                              overlapping_rsIDs[[i]][[1]][k, 2] <-  ifelse(str_detect(paste0(a[a$chr==i,][-k,'snp'][output[[i]][[k]]$yid,]), 'character'), NA , paste0(unlist(a[a$chr==i,][-k,'snp'][output[[i]][[k]]$yid,]), collapse = '-'))
                              overlapping_rsIDs[[i]][[1]][k, 3] <-  paste0(as.character(a[a$chr==i, ][k,]$snp))
                          
                }
                
              #remove NA
              overlapping_rsIDs[sapply( overlapping_rsIDs , is.null)] <- NULL
                
                
              }
              
              
              # #prepare the list for merging
              for(i in (1:length(overlapping_rsIDs))){
                overlapping_rsIDs[[i]] <- overlapping_rsIDs[[i]][[1]]
              }
              
              #merge and return
              end_data  <-do.call(rbind, overlapping_rsIDs)
              return(end_data)
              
              
              } else {
              
              a <-as.data.table(input_a)
              b <- as.data.table(input_b)
              
              a$chr <- as.numeric(a$chr)
              a$start <- as.numeric(a$start)
              a$end <- as.numeric(a$end)
              
              b$chr <- as.numeric(b$chr)
              b$start <- as.numeric(b$start)
              b$end <- as.numeric(b$end)
              
              output <- list()
              overlapping_rsIDs <- list()
              
                    for(i in c(1:n_chr)){
                      setkey(b,start, end)
                      output[[i]] <- foverlaps(a[a$chr==i,], b[b$chr==i,], type = 'any', which = TRUE, nomatch =NULL)
                      names(output)[[i]] <- paste0('CHR',i)
                      
                      #return the ovelapping SNPs
                      overlapping_rsIDs[[i]] <- input_b[output[[i]]$yid, 'SNP' ]
                      
                    }
              
              #return the overlapping loci defined by rsIDs
              return(overlapping_rsIDs)   
              
        }
            
  
  
}


```

## test_overlap_each

This function test the overlapp between two datasets. You need to provide the two datasest and the number of chromosomes where you want to perform the overalpp test. It expects the columns to be named CHR, start, end. It outputs a vector of overlapping loci. 
By selection auto_overlapp==T you provide just one dataset and the function will search for the overlapp inside the dataset. The function will return a list of SNP with their respective overlap. 
the iteration counter will be an indicator of the chromosome. 
This version of the function will return each interaction only once!!!! Because once the SNP has been tested, it's then taken out from the dataset. 

```{r test_overlap_each}
test_overlap_each <-function(input_a, input_b=NA, auto_overlapp=F){     
  require(data.table)
  require(stringr)
  
  if(auto_overlapp==T){ 
    
    #allocate the lists
    output <- list()
    colnames(input_a) <- tolower(colnames(input_a))
    overlapping_rsIDs <- list()
    
    #loop through each chromosome 
    for(i in c(unique(as.numeric(input_a$chr)))){
      #make sure everyhting is numeric
      a <-as.data.table(input_a)
      b <- as.data.table(input_a)
      
      a$chr <- as.numeric(a$chr)
      a$start <- as.numeric(a$start)
      a$end <- as.numeric(a$end)
      
      #allocate the lists
      overlapping_rsIDs[[i]] <-  list()
      overlapping_rsIDs[[i]][[1]] <- data.frame('iteration'=NA,'Overlapp_with_query'=NA,'Query_SNP'=NA)
      output[[i]] <- list()
      
      #loop for checking the overlapp between each element and the rest of the list
      for(k in c(1:nrow(a[a$chr==i, ]))){
        
        output[[i]][[k]] <- list()
        
        #select the SNP dataset to compare
        test_SNP <- as.data.table(a[a$chr==i, ][1,])
        test_SNP$chr<- as.numeric(test_SNP$chr)
        test_SNP$start<- as.numeric(test_SNP$start)
        test_SNP$end<- as.numeric(test_SNP$end)
        
        group_b <- as.data.table(a[a$chr==i,][-1,])
        group_b$chr <- as.numeric(group_b$chr)
        group_b$start <- as.numeric(group_b$start)
        group_b$end <- as.numeric(group_b$end)
        
        setkey(group_b,start, end)
        output[[i]][[k]] <- foverlaps(test_SNP, group_b, type = 'any', which = TRUE, nomatch =NULL)
        
        #put the results in a list
        overlapping_rsIDs[[i]][[1]][k, 1] <-  paste0(i,'-', k)
        overlapping_rsIDs[[i]][[1]][k, 2] <-  ifelse((length(output[[i]][[k]]$yid) == 0) , NA , paste0(unlist(group_b[output[[i]][[k]]$yid,'snp']), collapse = '-'))
        overlapping_rsIDs[[i]][[1]][k, 3] <-  paste0(as.character(test_SNP$snp))
        
        a <-   a[!a$snp==test_SNP$snp, ]
        
      }
      
      #remove NA
      overlapping_rsIDs[sapply( overlapping_rsIDs , is.null)] <- NULL
      
      
    }
    
    
    # #prepare the list for merging
    for(i in (1:length(overlapping_rsIDs))){
      overlapping_rsIDs[[i]] <- overlapping_rsIDs[[i]][[1]]
    }
    
    #merge and return
    end_data  <-do.call(rbind, overlapping_rsIDs)
    return(end_data)
    
    
  } else {
    
    a <-as.data.table(input_a)
    b <- as.data.table(input_b)
    
    a$chr <- as.numeric(a$chr)
    a$start <- as.numeric(a$start)
    a$end <- as.numeric(a$end)
    
    b$chr <- as.numeric(b$chr)
    b$start <- as.numeric(b$start)
    b$end <- as.numeric(b$end)
    
    output <- list()
    overlapping_rsIDs <- list()
    
    for(i in c(1:22)){
      overlapping_rsIDs[[i]] <-  list()
      overlapping_rsIDs[[i]][[1]] <- data.frame('iteration'=NA,'SNP_A'=NA,'SNP_B'=NA)
      
      
      setkey(b,start, end)
      output[[i]] <- foverlaps(a[a$chr==i,], b[b$chr==i,], type = 'any', which = TRUE, nomatch =NULL)
      names(output)[[i]] <- paste0('CHR',i)
      
      #save the overlapping
      overlapping_rsIDs[[i]][[1]] <- data.frame(
        'iteration'=rep(i, length(output[[i]]$yid)),
        'SNP_input_a'=input_a[output[[i]]$xid, 'SNP' ],
        'SNP_input_b'= input_b[output[[i]]$yid, 'SNP' ]
      ) 
      #keep truck of the iteration that return a positive hit
      index[i] <- (length(output[[i]]$yid) > 0)
      
    }
    
    end_data <- list()
    
    #prepare for return
    for(q in c(1:length(overlapping_rsIDs[c(index)])) ){
      end_data[[q]] <- overlapping_rsIDs[c(index)][[q]][[1]]
    }
    
    #merge and return
    end_data  <-do.call(rbind, end_data)
    return(end_data)
    
    
  }
  
}

```

##prepare_plot

a functio to prepare sumary stats to be plotted

```{r prepare_plot}
prepare_plot <-  function(res, Pval_col,plimit=0.005, BP='BP', CHR='CHR') {
  require(dplyr)
  res[,Pval_col] <- as.numeric(res[, Pval_col])
  res[, CHR] <- as.numeric(res[, CHR])
  res <- res[res[, CHR] %in% c(1:22),]
  output <- res[(which(!is.na(res[,Pval_col]))),]
  output <- output[which(output[, Pval_col] <  plimit),]
  output <- rename(output, BP=all_of(BP), CHR=all_of(CHR), p=all_of(Pval_col) )
  return(output)
}
```
